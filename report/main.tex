\documentclass{article}
\usepackage{listings}
\usepackage{listings}
\usepackage{xcolor}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{code}{
    backgroundcolor=\color{codegray},
    basicstyle=\ttfamily\footnotesize,
    keywordstyle=\color{codeblue},
    commentstyle=\color{green},
    stringstyle=\color{red},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\definecolor{codegray}{gray}{0.9}
\definecolor{codeblue}{rgb}{0.0, 0.0, 0.5}

\lstset{style=code}
% Language setting
% Replace `english' with e.g. `spanish' to change the document language
\usepackage[english]{babel}

% Set page size and margins
% Replace `letterpaper' with `a4paper' for UK/EU standard size
\usepackage[letterpaper,top=2cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}

% Useful packages
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[colorlinks=true, allcolors=blue]{hyperref}

\title{Operations Reserach 2 Final Thesis}
\author{Youssef Ben Khalifa}

\begin{document}
\maketitle

\section{Introduction}

In this thesis we will go over the implementation of the main heuristics involving the famous TSP problem. The entire implementation is done using the C programming language and the CPLEX optimization LP optimization framework.
\subsection{The Traveling Salesman Problem}
The Traveling Salesman Problem is among the most disucssed and researched problems in the field of Operations Research.

\paragraph{Mathematical Formulation}
The TSP can be formulated as an optimization problem as follows:
\begin{equation}
	\min \sum_{i=1}^{n} \sum_{j=1}^{n} c_{ij} x_{ij}
\end{equation}
subject to:
\begin{equation}
	\sum_{i=1}^{n} x_{ij} = 1 \quad \forall j \in \{1, \ldots, n\}
\end{equation}
\begin{equation}
	\sum_{j=1}^{n} x_{ij} = 1 \quad \forall i \in \{1, \ldots, n\}
\end{equation}
\begin{equation}
	u_i - u_j + nx_{ij} \leq n-1 \quad \forall i \in \{2, \ldots, n\}, j \in \{2, \ldots, n\}
\end{equation}
\begin{equation}
	x_{ij} \in \{0, 1\} \quad \forall i, j \in \{1, \ldots, n\}
\end{equation}
\begin{equation}
	u_i \in \mathit{text} \quad \forall i \in \{1, \ldots, n\}
\end{equation}


\section{TSP data structure}
Throught the implementation of the Metaheuristics and Mathheuristics, we will be using the following data structures:
\begin{itemize}
	\item \text{instance} : A structure that holds the TSP instance data. This is implemented as a C data structure
	      in which we hold all the metadata relevant to the loaded TSP instance.
	\item \text{solution} : A structure that holds the TSP solution data. Normally this is represented as a simple integer array in which we map for every nodex
	      index its successor in the tour. This type of solution representation suits both the indirected and directed graph cases.
\end{itemize}
The code for the data structures implementation can be found in the appendinx section.

The cost functio used is the euclidean distance between two nodes in the graph.
The code for the implementation can be found in the appendix section \ref{appendix:euclidean_distance}.
\section{TSP Heurisitcs}
\subsection{Greedy Randomized Adaptive Search (GRASP)}
The GRASP method is basically a greedy randomized adaptive search procedure.
It consists of two main phases: construction and local search.
In the construction phase, a feasible solution is built, one element at a time, in a greedy randomized fashion.
In the local search phase, the neighborhood of the constructed solution is explored until a local minimum is found.

\paragraph{Construction Phase}
In the construction phase, the solution is built iteratively. At each iteration, a candidate list is created,
containing the best elements to be added to the solution. One of these elements is chosen randomly, according
to a probability distribution, and added to the solution.

\paragraph{Local Search Phase}
In the local search phase, the algorithm explores the neighborhood of the constructed solution to find a local minimum.
This is done by iteratively replacing the current solution with a better solution from its neighborhood,
until no better solution can be found.

\paragraph{Algorithm}
The GRASP algorithm can be summarized as follows:
\begin{enumerate}
	\item \textbf{Initialization:} Set the best solution found to null.
	\item \textbf{Construction:} Build a feasible solution using the greedy randomized approach.
	\item \textbf{Local Search:} Improve the constructed solution using local search.
	\item \textbf{Update:} If the improved solution is better than the best solution found, update the best solution.
	\item \textbf{Termination:} Repeat steps 2-4 until a stopping criterion is met (e.g., a maximum number of iterations).
\end{enumerate}

\paragraph{Implementation}
The implementation of the GRASP algorithm takes as input arguments:
\begin{itemize}
	\item \texttt{instance}: The TSP instance data structure.
	\item \texttt{start\_node}: The index of the starting node for the tour.
\end{itemize}
\begin{lstlisting}[language=C]
	void tsp_grasp(instance* inst, int starting_node);
\end{lstlisting}
The function internally allocates and sets the solution as an array integers representing the tour....
The GRASP algorithm is implemented as follows:
\begin{enumerate} 
	\item \textbf{Setup}:
	      \begin{itemize}
		      \item The function initializes the current node index to the starting node (which is passed as an argument) 
			  and sets the remaining nodes count to the total number of nodes.
		      \item It allocates memory for the solution array and remaining nodes arrays. These two arrays will be used respectively to store the tour and the remaining nodes for the main loop to visit.
		      \item The solution array is initialized with \texttt{-1} to indicate that no nodes have been visited yet.
		      \item The remaining nodes array is initialized with all node indices.
	      \end{itemize}

		\begin{lstlisting}[language=C]
			clock_t start_time = clock();
			int current_node_index = starting_node;
			int remaining_nodes_count = inst->nnodes;
			solution nearest_node;
			int* remaining_nodes = (int*)malloc(inst->nnodes * sizeof(int));
			inst->solution = (int*)malloc(inst->nnodes * sizeof(int));
			inst->best_cost_value = 0;
			for (int i = 0; i < inst->nnodes; i++) {
				inst->solution[i] = -1;
				remaining_nodes[i] = i;
			}
			remaining_nodes[current_node_index] = remaining_nodes[--remaining_nodes_count];
		\end{lstlisting}

	\item \textbf{Main Loop}:
	      \begin{itemize}
		      \item The function iterates over all nodes to construct the solution.
		      \item For each node, it finds the nearest unvisited node using the \texttt{euclidean\_nearest\_node} function.
		      \item If no nearest node is found (i.e., all nodes are visited), it connects the current node back to the starting node to complete the tour.
		      \item Otherwise, it updates the solution with the nearest node and logs the current node index and nearest node found.
		      \item The current node index is updated to the nearest node for the next iteration.
	      \end{itemize}
		  \begin{lstlisting}[language=C]
			for (int i = 0; i < inst->nnodes; i++) {
				nearest_node = euclidean_nearest_node(inst, current_node_index, remaining_nodes, &remaining_nodes_count);
				if (nearest_node.node == -1) {
					inst->solution[current_node_index] = starting_node;
					inst->best_cost_value += euclidean_distance(inst->xcoord[current_node_index],
																inst->ycoord[current_node_index],
																inst->xcoord[starting_node],
																inst->ycoord[starting_node], false);
					continue;
				}
				inst->solution[current_node_index] = nearest_node.node;
				inst->best_cost_value += nearest_node.cost;
				current_node_index = nearest_node.node;
    		}
		  \end{lstlisting}

	\item \textbf{Finalization}:
	      \begin{itemize}
		      \item After constructing the solution, the function records the end time and calculates the elapsed time.
		      \item It logs the total time taken and the cost of the solution.
		      \item Finally, it frees the allocated memory for the remaining nodes array.
	      \end{itemize}
		\begin{lstlisting}[language=C]
			clock_t end_time = clock();
			double elapsed_time = ((double) (end_time - start_time)) / CLOCKS_PER_SEC;
			inst->elapsed_time = elapsed_time;
			inst->best_cost_value = compute_solution_cost(inst, inst->solution);
		\end{lstlisting}
\end{enumerate}

The complete code of the imeplementation can be found in the appendix section\ref{appendix:tsp_grasp}.

\subsection{Extra Mileage}
In the extra mileage heuristic, we try to build a valid tsp solution starting an edge of the graph and we try and build a tour by selecting the adjacent edge with the minimum cost.

\paragraph{Algorithm}
The extra mileage algorithm can be summarized as follows:
\begin{enumerate}
	\item \textbf{Initialization:} Initialize the starting edge.
	\item \textbf{Construction:} Build a feasible solution by iteratively selecting the edge with the minimum cost.
	\item \textbf{Update:} If the improved solution is better than the best solution found, update the best solution.
	\item \textbf{Termination:} Repeat steps 2-3 until a stopping criterion is met (e.g., a maximum number of iterations).
\end{enumerate}

\paragraph{Implementation}
The extra mileage algoithm imeplementation takes as input arguments:
\begin{itemize}
	\item \texttt{instance}: The TSP instance data structure.
	\item \texttt{starting\_pair}: The pair of nodes that will be used to start the tour.
\end{itemize}
\begin{lstlisting}[language=C]
	void tsp_extra_mileage(instance* inst, pair starting_pair);
\end{lstlisting}
where the $pair$ data structure is defined as follows:
\begin{lstlisting}[language=C]
	typedef struct {
		int node1;
		int node2;
	} pair;
\end{lstlisting}
An heuristic state data stcuture is also used to keep track of the covered nodes and the final solution.
\begin{lstlisting}[language=C]
	typedef struct
	{
		int covered_nodes_count;
		int* covered_nodes;
		int uncovered_nodes_count;
		int* uncovered_nodes;
	} heuristic_state;
\end{lstlisting}

Ideally the starting pair should be the most distant pair of nodes in the graph in order to optimize the construction of the solution,
by design this is not a restriction that has been instrisically implemented into the function, so any pair of nodes can be used as a starting pair.
The extra mileage algorithm is implemented as follows:
\begin{enumerate} 
	\item \textbf{Setup}:
	\begin{itemize}
		\item The function initializes the current\_pair to the starting pair (which is passed as an argument).
		\item An heuristic state data stcuture is initialized to keep the track of the covered nodes and the final solution 
	\end{itemize}
	\begin{lstlisting}[language=C]
		clock_t start_time = clock();
		heuristic_state state;
		pair current_pair = starting_pair;
		initialize_instance(inst, &state);
		inst->solution[current_pair.node1] = current_pair.node2;
		inst->solution[current_pair.node2] = current_pair.node1;
		state.covered_nodes[state.covered_nodes_count++] = current_pair.node1;
		state.covered_nodes[state.covered_nodes_count++] = current_pair.node2;
		state.uncovered_nodes[current_pair.node1] = state.uncovered_nodes[--state.uncovered_nodes_count];
		state.uncovered_nodes[current_pair.node2] = state.uncovered_nodes[--state.uncovered_nodes_count];
	\end{lstlisting}
	\item \textbf{Main Loop}:
	      \begin{itemize}
		      \item While there are uncovered nodes (condition based on the comparison of the covered nodes count and the total number of nodes), 
			  the function iterates over the uncovered nodes to construct the solution:
		            \begin{itemize}
			            \item For each covered node, a second loop is exectued to find the nearest uncovered node such that 
			            the the resulting edge between the two nodes is the argument that minimizes the total cost of the tour up until that point.
			            \item if such node is found, that node is selected and added to the tour, 
						the covered nodes count is incremented and the node is removed from the uncovered nodes list.
		            \end{itemize}
	      \end{itemize}
		  \begin{lstlisting}[language=C]
			while (state.covered_nodes_count < inst->nnodes)
			{
				log_message(LOG_LEVEL_INFO, "Covered nodes count: %d\n", state.covered_nodes_count);
				solution best_node;
				for (int i = 0; i < state.covered_nodes_count; i++)
				{
					log_message(LOG_LEVEL_INFO, "Current node index: %d\n", i);
					int current_node = state.covered_nodes[i];
					int current_node_opposite = inst->solution[current_node];
					double min_distance_delta = INFINITY;
					best_node.node = -1;
					best_node.node_index = -1;
					for (int j = 0; j < state.uncovered_nodes_count; j++)
					{
						double distance1 = euclidean_distance(inst->xcoord[current_node],
															inst->ycoord[current_node],
															inst->xcoord[state.uncovered_nodes[j]],
															inst->ycoord[state.uncovered_nodes[j]], false);
						double distance2 = euclidean_distance(inst->xcoord[state.uncovered_nodes[j]],
															inst->ycoord[state.uncovered_nodes[j]],
															inst->xcoord[current_node_opposite],
															inst->ycoord[current_node_opposite], false);
						double existing_pair_distance = euclidean_distance(inst->xcoord[current_node],
																		inst->ycoord[current_node],
																		inst->xcoord[current_node_opposite],
																		inst->ycoord[current_node_opposite], false);

						double distance_delta = distance1 + distance2 - existing_pair_distance;

						if (distance_delta < min_distance_delta)
						{
							min_distance_delta = distance_delta;
							best_node.node = state.uncovered_nodes[j];
							best_node.node_index = j;
							best_node.cost = distance_delta;
						}
					}
					if (best_node.node > -1)
					{
						log_message(LOG_LEVEL_INFO, "Best node found: %d\n", best_node.node);
						inst->solution[current_node] = best_node.node;
						inst->solution[best_node.node] = current_node_opposite;
						state.covered_nodes[state.covered_nodes_count++] = best_node.node;
						state.uncovered_nodes[best_node.node_index] = state.uncovered_nodes[--state.uncovered_nodes_count];
					}
				}
    		}
		  \end{lstlisting}

	\item \textbf{Finalization}:
	      \begin{itemize}
		      \item Once all nodes are covered, the function calculates the total cost of the solution.
		      \item It records the end time and calculates the elapsed time.
	      \end{itemize}
		  \begin{lstlisting}[language=C]
			inst->best_cost_value = compute_solution_cost(inst, inst->solution);
			clock_t end_time = clock();
			double elapsed_time = ((double)(end_time - start_time)) / CLOCKS_PER_SEC;
			inst->elapsed_time = elapsed_time;
		  \end{lstlisting}
\end{enumerate}
the code for the implementation can be found in the appendix section \ref{appendix:tsp_extra_mileage}.

\subsection{Tabu Search}
The main idea behind the Tabu search heuristic is to exclude the already explored solutions from the search space. This is done by maintaining a tabu list that stores the solutions that have been visited recently. 
The tabu list is used to prevent the search from revisiting the same solutions, which can help the algorithm escape local optima and explore new regions of the search space.

\paragraph{Algorithm}
The Tabu search algorithm can be summarized as follows:
\begin{enumerate}
    \item \textbf{Initialization:} Initialize the tabu list and the best solution found.
    \item \textbf{Setup:} Initialize the current solution and the current iteration count.
    \item \textbf{Main Loop:} Repeat the following steps until a stopping criterion is met:
          \begin{itemize}
              \item Generate a set of candidate solutions by applying a set of moves to the current solution.
              \item Select the best candidate solution that is not in the tabu list.
              \item Update the tabu list with the selected solution.
              \item Update the current solution with the selected solution.
              \item If the selected solution is better than the best solution found, update the best solution.
              \item Increment the iteration count.
          \end{itemize}
    \item \textbf{Finalization:} Return the best solution found.
\end{enumerate}

\subsection{Variable Neighbourhood Search}
The Variable Neighbourhood Search (VNS) heuristic is a metaheuristic that combines local search with a systematic change of neighbourhood structures. 
The idea is to explore different neighbourhoods of the current solution to escape local optima and find better solutions.
Many formulations and version for the VNS algorithm have been proposed in the literature, such as the \textit{Basic VNS}, \textit{Reduced VNS} and \textit{General VNS}.\cite{VariableNeighborhood_Search}
All of these forumlations are based on a neighbourhood search, which is defined within a solution space that can be explored using the \textit{two-opt move}, 
\textit{three-opt move} or the \textit{k-opt move}, depending on the general scheme of the algorithm. These operations that can be made in the solution space for the TSP problem allow to generate a neighborhood
starting from a given solution, each of which neighbour differ from one single \textit{k-opt move}. \cite{Heuristics_for_the_Traveling_Salesman_Problem} 

\paragraph{Algorithm}
In our imeplementation we will go over the General VNS scheme, in which the neighbours are simply generated from a single \textit{two-opt move}, and the \textit{shaking function} 
The VNS algorithm can be summarized as follows:
\begin{enumerate}
	\item \textbf{Initialization:} Initialize the current solution and the best solution found.
	\item \textbf{Setup:} Initialize the neighbourhood structure and the current iteration count.
	\item \textbf{Main Loop:} Repeat the following steps until a stopping criterion is met:
		  \begin{itemize}
			  \item Apply a local search algorithm to the current solution.
			  \item Generate a new solution by applying a perturbation to the current solution.
			  \item If the new solution is better than the current solution, update the current solution.
			  \item If the current solution is better than the best solution found, update the best solution.
			  \item Change the neighbourhood structure.
			  \item Increment the iteration count.
		  \end{itemize}
	\item \textbf{Finalization:} Return the best solution found.
\end{enumerate}


\section{TSP with CPLEX}
\subsection{Modeling the TSP with CPLEX}

\subsection{Bender's subtour elimination method}

\subsection{Patching Heuristic}

\subsection{CPLEX Callback implementation}


\newpage

\bibliographystyle{alpha}
\bibliography{sample}

\include{appendix}

\end{document}